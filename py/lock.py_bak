"""
Maksim Yegorov
mey5634@rit.edu
2017-04-09 Sun 03:11 AM

"""

import threading
import logging

NUM_PROCESSES = 5

class Lock:
    """ Data structures shared by active & passive sockets:
        - holder of this node (int)
        - using CS (bool): True iff currently executing CS
        - request queue: can contain self, or one's neighbors
        - asked (bool): has this node sent request for token

    """

    def __init__ (self, pid, dns):
        self.lock = threading.RLock()
        self.dns = dns
        self.pid = pid

        self.executing_election = False
        self.elected = None # pid of leader (int, if set)
        self.am_asleep = False

        # TODO: need to suppress elections if multiple
        # election number that will not be suppressed
        self.election_num = 0

        # procs that responded to my election message this cycle
        self.acked = {i:None for i in range(self.pid+1,NUM_PROCESSES)} 
        # only the self.alive[self.elected] is significant, other entries not used
        self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}

        logging.basicConfig(
            level=logging.DEBUG,
            format ='%(message)s',
        )

    def increment_election(self):
        """Increment and return election number to use."""
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)
            self.election_num += 1
            return self.election_num
        finally:
            self.lock.release()


    def am_leader(self):
        """Am I elected leader?"""

        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep:
                return False

            return self.pid == self.elected
        finally:
            self.lock.release()

    def am_sleeping(self):
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            return self.am_asleep

        finally:
            self.lock.release()

    def fall_asleep(self):
        """Used to simulate failure of a process.
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            self.am_asleep = True

            logging.debug("[%d] - falling asleep (mimicking failure)"
                    %(  self.pid))

        finally:
            self.lock.release()


    def wake_up(self):
        """Used to simulate a process coming online.
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            self.am_asleep = False
            # clean up in case didn't shut down properly
            self.executing_election = False
            self.elected = None

            logging.debug("[%d] - coming online (mimicking wakeup from failure)"
                    %(  self.pid))

        finally:
            self.lock.release()



    def got_heartbeat(self, proc_num):
        """Whenver get a heartbeat messages (sent by the 
        proc that considers itself leader): Call for election if
        spurious leader (may happen for a proc that just woke up/came 
        online).

        :param proc_num (int): pid of `leader` (keyed to HOSTS)
        :returns (Boolean): True iff need to start election
        """

        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep:
                return False

            if proc_num < self.pid and not self.executing_election:

                logging.debug("[%d] - got spurious heartbeat or coordinator msg from #%d"
                        %(  self.pid,
                            proc_num
                         ))

                # self.call_election_start()
                return True
            else: # assume leader acts in good faith

                self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}
                self.alive[proc_num] = True
                if self.elected != proc_num and not self.executing_election:
                    self.elected = proc_num

                    logging.debug("[%d] - setting leader -> #%d"
                            %(  self.pid,
                                proc_num
                            ))
                return False

        finally:
            self.lock.release()


    def leader_is_alive(self):
        """Every so often, check if leader is alive based on got_heartbeat()
        :returns (Boolean): True iff leader is alive judging by got_heartbeat()
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep or self.am_leader():
                return True

            if self.elected is not None:
                status = self.alive[self.elected]
                if not status:
                    logging.debug("[%d] - oops, looks like #%d failed, will start election..."
                            %(  self.pid,
                                self.elected
                            ))


                # reset self.alive
                self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}
                #self.alive[self.elected] = False # reset self.alive
                return status

            return False

        finally:
            self.lock.release()


    def got_coordinator_msg(self, proc_num):
        """On receiving coordinator message, run set_leader().

        :returns (Boolean): True iff need to start election.
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep:
                return False

            self.executing_election = False
            #if self.elected is not None and self.elected != proc_num:
            logging.debug("[%d] - got coordinator msg from #%d"
                    %(  self.pid,
                        proc_num
                    ))

            return self.got_heartbeat(proc_num)

        finally:
            self.lock.release()


    def got_election_msg(self, proc_num, election_num):
        """Acknowledgement has already been sent.
        Now suppress the election if already in the midst of own election.
        :returns (Boolean): True iff need to start election campaign
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep:
                return False

            if not self.executing_election and self.election_num <= election_num:

                self.election_num = election_num
                logging.debug("[%d] - got election msg from #%d"
                        %(  self.pid,
                            proc_num
                        ))

                # self.call_election_start()
                return True

            logging.debug("[%d] - got election msg from #%d, responded & discarded..."
                    %(  self.pid,
                        proc_num
                    ))

            return False

        finally:
            self.lock.release()

    def got_ack_msg(self, proc_num):
        """Register acknowledgement from proc_num to my election message."""

        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            if self.am_asleep:
                return

            if self.executing_election:
                self.acked[proc_num] = True

                logging.debug("[%d] - got ACK from #%d"
                        %(  self.pid,
                            proc_num
                        ))
            else: # otherwise ignore ACK
                logging.debug("[%d] - got ACK from #%d, discarding..."
                        %(  self.pid,
                            proc_num
                        ))

        finally:
            self.lock.release()


    def call_election_start(self):
        """
        :returns proc_ips(List(String)): list of proc ips to send election message to;
                                        if empty list -> send coordinator message;
                                        if [-1] -> do nothing
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            # check if already in the midst of election
            if self.executing_election:
                return [-1]

            # reset all election tracking
            self.acked = {i:None for i in range(self.pid+1,NUM_PROCESSES)} 
            self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}

            # determine if I have highest id -> declare self leader
            if self.pid == NUM_PROCESSES - 1:

                logging.debug("[%d] - declaring self leader & sending coordinator msg to everyone..."
                        %(  self.pid
                        ))

                self.elected = self.pid
                self.executing_election = False
                return [] # send out a coordinator message instead

            self.executing_election = True
            self.elected = None

            ips = [ip for ip in [self.dns.get_ip(j) for j in self.acked.keys()]]

            logging.debug("[%d] - sending election msg to higher procs..."
                    %(  self.pid
                    ))

            return ips

        finally:
            self.lock.release()


    def call_election_end(self):
        """Check if received ACKS and/or coordinator msg.
        Then either declare election finished or restart election.

        :returns proc_ips(List(String)): list of proc ips to send election 
                                        message to; if empty list -> 
                                        send coordinator message;
                                        if [-1] -> done with election, stop
        """
        try:
            acquired_lock = False
            while not acquired_lock:
                acquired_lock = self.lock.acquire(0)

            self.executing_election = False

            if self.elected is not None:
                # reset all election tracking
                self.acked = {i:None for i in range(self.pid+1,NUM_PROCESSES)} 
                self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}

                #logging.debug("[%d] - election over..."
                #        %(  self.pid
                #        ))

                return [-1] # flag end of election, no further messages

            # no-one acked -> declare self leader
            if not any(set(self.acked.values())):
                logging.debug("[%d] - no ACKs received, sending out coordinator msg..."
                        %(  self.pid
                        ))

                self.elected = self.pid
                # reset all election tracking
                self.acked = {i:None for i in range(self.pid+1,NUM_PROCESSES)} 
                self.alive = {i:False for i in range(self.pid+1,NUM_PROCESSES)}
                return [] # send out coordinator messages to everyone
            else: # received ACKs, but not coordinator messages
                logging.debug("[%d] - received (some) ACKs but not coordinator msg.\n \tStarting new election..."
                        %(  self.pid
                        ))
                return self.call_election_start()

        finally:
            self.lock.release()


if __name__ == "__main__":

    from dns import DNS

    # start three procs: 2, 3, 4
    dns2 = DNS(host='129.21.37.217')
    proc2 = Lock(2, dns2)
    proc2_to_call = proc2.call_election_start()
    assert (proc2_to_call == ['129.21.37.203', '129.21.37.46'])


    dns3 = DNS(host='129.21.37.203')
    proc3 = Lock(3, dns3)

    dns4 = DNS(host='129.21.37.46')
    proc4 = Lock(4, dns4)
    proc4.fall_asleep()
    assert (proc4.am_asleep == True) 
    proc4_need_end_election = proc4.got_election_msg(2)
    assert (proc4_need_end_election == False)

    proc3_need_end_election = proc3.got_election_msg(2)
    assert (proc3_need_end_election == True)
    proc2.got_ack_msg(3)
    assert (proc2.acked[3] == True)

    # this shouldn't do anything
    # already in the midst of election
    proc3_to_call = proc3.call_election_start()
    assert (proc3_to_call == [-1])

    proc2_to_call = proc2.call_election_end()
    assert (proc2_to_call == ['129.21.37.203', '129.21.37.46'])
    proc3_to_call = proc3.call_election_end()
    assert (proc3_to_call == [])

    proc2_need_end_election = proc2.got_coordinator_msg(3)
    assert (proc2_need_end_election == False)

    proc2_need_end_election = proc2.got_heartbeat(3)
    assert (proc2_need_end_election == False)
    leader_alive = proc2.leader_is_alive()
    assert (leader_alive == True)
    # after reset
    leader_alive = proc2.leader_is_alive()
    assert (leader_alive == False)


    proc4.wake_up()
    proc4_need_end_election = proc4.got_heartbeat(3)
    assert (proc4_need_end_election == True)

    proc2_need_end_election = proc2.got_coordinator_msg(4)
    assert (proc2_need_end_election == False)
    proc3_need_end_election = proc3.got_coordinator_msg(4)
    assert (proc3_need_end_election == False)

